"""
    detect_frame_pattern(output_dir; rx=r"frame_(\d+)\.png")

Scan `output_dir` for image frames and derive the printf-style pattern used by
FFmpeg. The default regular expression matches files named like
`frame_0001.png` and extracts the zero-padded index to determine the required
padding width. Returns a string such as `"frame_%04d.png"`. Throws an
`ArgumentError` if no matching files are found.
"""
function detect_frame_pattern(output_dir::String, rx = r"frame_(\d+)\.png")
    for file in readdir(output_dir)
        m = match(rx, file)
        if !isnothing(m)
            num_str = m.captures[1]
            ndigits = length(num_str)
            return "frame_%0$(ndigits)d.png"
        end
    end
    throw(ArgumentError("No frame_*.png files found in $output_dir"))
end

"""
    ffmpegcall(output_dir::String, output_path::String="mobius.mp4", fps::Int=30, resolution::Tuple{Int,Int}=(1280, 720), quality::Symbol=:high)

Converts a sequence of image frames in `output_dir` into a video file (.mp4 or .gif) using FFmpeg.

# Arguments
- `output_dir::String`: Path to the directory containing the input frames.
- `output_path::String`: Path for the output video file (default "mobius.mp4").
- `fps::Int`: Frames per second for the output video (default 30).
- `resolution::Tuple{Int,Int}`: Target resolution (width, height) for the output (default (1280, 720)).
- `quality::Symbol`: Quality setting for MP4 encoding (default :high). Used by `quality_settings`.
"""
function ffmpegcall(
    output_dir,
    output_path::String="mobius.mp4",
    fps::Int=30,
    resolution::Tuple{Int,Int}=(1280, 720),
    quality::Symbol=:high
)
    # üîç Auto-detect frame numbering format
    frame_pattern = detect_frame_pattern(output_dir)

    # Determine the output format and construct the appropriate command
    # ffmpeg_path = FFMPEG.ffmpeg_exe() # Get the path to the FFmpeg binary managed by FFMPEG.jl
    ffmpeg_path = "ffmpeg"

    if endswith(output_path, ".mp4")
        cmd = _build_mp4_command(ffmpeg_path, frame_pattern, fps, output_path, quality)
    elseif endswith(output_path, ".gif")
        cmd = _build_gif_command(ffmpeg_path, frame_pattern, fps, resolution, output_path)
    else
        error("Unsupported output format '$(output_path)'. Use .mp4 or .gif")
    end

    # Execute the command in the specified directory
    run(Cmd(cmd, dir=output_dir))
end


# --- Internal Helper Functions for Command Construction ---

"""
    _build_mp4_command(ffmpeg_path, frame_pattern, fps, output_path, quality)

Constructs the FFmpeg command for encoding an MP4 video.
"""
function _build_mp4_command(ffmpeg_path::String, frame_pattern::String, fps::Int, output_path::String, quality::Any)
    # Retrieve quality settings (e.g., preset and CRF) from a configuration function
    settings = quality_settings(quality).ffmpeg

    # --- Command Construction ---
    # The command is built as an array of strings to be passed to FFmpeg

    # 1. FFmpeg executable path
    command_parts = [ffmpeg_path]

    # 2. Global options
    # -y: Automatically overwrite the output file if it already exists (no prompt)
    push!(command_parts, "-y")

    # 3. Input options
    # -framerate $fps: Specify the input frame rate (frames per second) for the image sequence
    # -i $frame_pattern: Specify the input file pattern (e.g., img%03d.png)
    append!(command_parts, ["-framerate", "$fps", "-i", frame_pattern])

    # 4. Video encoding options (applied to the output video stream)
    # -c:v libx264: Use the H.264 video codec (widely supported, good compression)
    append!(command_parts, ["-c:v", "libx264"])

    # -preset $(settings.preset): Balance encoding speed vs. compression efficiency.
    #   e.g., "ultrafast", "superfast", "veryfast", "faster", "fast", "medium", "slow", "slower", "veryslow".
    #   Slower presets usually produce smaller files for the same quality.
    append!(command_parts, ["-preset", settings.preset])

    # -crf $(settings.crf): Constant Rate Factor (controls quality vs. file size).
    #   Lower values (e.g., 18) mean higher quality and larger file size.
    #   Higher values (e.g., 28) mean lower quality and smaller file size.
    #   A common range is 18-28. 18 is visually lossless.
    append!(command_parts, ["-crf", "$(settings.crf)"])

    # -pix_fmt yuv420p: Set the pixel format.
    #   yuv420p is widely compatible with players and platforms (like web browsers).
    #   Some players might not support other formats generated by default.
    append!(command_parts, ["-pix_fmt", "yuv420p"])

    # 5. Output file path
    push!(command_parts, output_path)

    # Return the command as a Cmd object for execution
    return Cmd(command_parts)
end

"""
    _build_gif_command(ffmpeg_path, frame_pattern, fps, resolution, output_path)

Constructs the FFmpeg command for encoding a GIF animation.
"""
function _build_gif_command(ffmpeg_path::String, frame_pattern::String, fps::Int, resolution::Tuple{Int, Int}, output_path::String)
    width, height = resolution

    # --- Command Construction ---
    # The command is built as an array of strings to be passed to FFmpeg

    # 1. FFmpeg executable path
    command_parts = [ffmpeg_path]

    # 2. Global options
    # -y: Automatically overwrite the output file if it already exists (no prompt)
    push!(command_parts, "-y")

    # 3. Input options
    # -framerate $fps: Specify the input frame rate (frames per second) for the image sequence
    # -i $frame_pattern: Specify the input file pattern (e.g., img%03d.png)
    append!(command_parts, ["-framerate", "$fps", "-i", frame_pattern])

    # 4. Video filter options (applied before encoding the output)
    # -vf: Specify a video filter chain.
    # The filter chain is built step-by-step for clarity.

    # Initialize the filter string
    filter_string = ""

    # a) fps=$fps:
    #    Ensures the output GIF runs at the specified frame rate.
    #    Input frames might be at a different rate than desired output rate.
    filter_string *= "fps=$fps,"

    # b) scale=$width:$height:flags=lanczos:
    #    Resizes the frames to the target resolution (width x height).
    #    The 'lanczos' flag specifies a high-quality resampling algorithm for better visual results.
    filter_string *= "scale=$width:$height:flags=lanczos,"

    # c) split[s0][s1]:
    #    Splits the video stream into two identical streams:
    #    - [s0]: Stream labeled 's0', used for palette generation.
    #    - [s1]: Stream labeled 's1', used for creating the final GIF using the palette.
    filter_string *= "split[s0][s1];"

    # d) [s0]palettegen[p]:
    #    Takes the stream [s0] and generates an optimal color palette (256 colors max for GIFs).
    #    The resulting palette is labeled as [p].
    filter_string *= "[s0]palettegen[p];"

    # e) [s1][p]paletteuse:
    #    Combines the original stream [s1] with the generated palette [p] to create the final GIF.
    #    This ensures the GIF uses the best colors determined by palettegen for optimal quality.
    filter_string *= "[s1][p]paletteuse"

    # Now that the filter_string is fully built, add it to the command parts
    append!(command_parts, ["-vf", filter_string])

    # 5. Output file path
    push!(command_parts, output_path)

    # Return the command as a Cmd object for execution
    return Cmd(command_parts)
end
